# General Rules
- You are an expert generic AI coding assistant for a Nuxt 4 project.
- The project follows a "Backend for Frontend" (BFF) pattern where the Nuxt server acts as a proxy to an external backend (Rust/Actix at http://localhost:8080).
- Use TypeScript for all code.
- Prefer `valibot` for validation.
- Use `Nuxt UI` for UI components.

# Project Structure
- **Root Directory**: `app/` (Nuxt 4 structure)
- **API Proxy Layer**: `server/api/` matches the backend routes and forwards requests.
- **Composables**: `app/composables/` contains business logic and API integration (e.g., `useAuth`, `useProfile`).
- **DTOs**: `app/types/dto/` contains Data Transfer Objects (Interfaces) for API responses and requests.
- **Pages**: `app/pages/` (Admin routes in `app/pages/admin/`).
- **Middleware**: `app/middleware/` for route protection (`auth.ts`, `guest.ts`).

# Coding Standards

## Backend Communication (BFF Pattern)
- Do NOT call the external backend directly from Vue components.
- Create a corresponding endpoint in `server/api/` that proxies the request using `$fetch`.
- Server endpoints should:
    - Extract headers (especially `Authorization`).
    - Use `readBody` for POST/PUT.
    - Handle errors gracefully (e.g., return standard error objects or status codes).
- URL Structure: `server/api/app/[resource]/[action].ts` maps to `http://localhost:8080/app/[resource]`.
- **Reference**: See `API_DOCUMENTATION.md` for detailed endpoint contract.

## Composables
- Encapsulate all API calls within composables.
- Manage loading state (`useState`) and error handling within the composable.
- Return explicit types (DTOs) from API calls.
- Example:
  ```typescript
  export const useFeature = () => {
    const loading = useState('feature_loading', () => false)
    const getData = async () => {
        // call internal /api/...
    }
    return { getData, loading }
  }
  ```

## UI Components
- Use `<script setup lang="ts">`.
- Use `Nuxt UI` components (e.g., `UButton`, `UInput`, `UForm`, `UCard`).
- Use `valibot` for form schemas.
- Do not put complex business logic in components; move to composables.

## CRUD Pattern
- Implement CRUD operations on a **single page** where possible.
- Use **Modals** (`UModal`) for **Create** and **Update** forms.
- Do not navigate to separate pages for creating or editing items unless the form is extremely complex.
- Use a data table (e.g., `UTable`) to list items with Actions (Edit/Delete).
- **Delete Confirmation**: ALWAYS ask for confirmation (e.g., using a Modal or Dialog) before deleting an item.
- **Feedback**: Use Toast notifications (`useToast`) for ALL success and failure actions (Create, Update, Delete).

## Authentication
- Auth Token is stored in a cookie (`auth_token`).
- `useAuth` composable handles login, logout, and token management.
- `is-login` endpoint (`/api/is-login`) verifies session validity.
- `Authorization: Bearer <token>` header must be passed manually in server proxy calls if needed.

## TypeScript
- Define interfaces for all data structures in `app/types/dto/`.
- Avoid `any` where possible. Use defined DTOs.
- Use generics with `$fetch`: `$fetch<{ data: MyDto }> (...)`.
